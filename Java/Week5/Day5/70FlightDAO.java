package Application.DAO;

import Application.Model.Flight;
import Application.Util.ConnectionUtil;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A DAO is a class that mediates the transformation of data between the format of objects in Java to rows in a
 * database. The methods here are mostly filled out, you will just need to add a SQL statement.
 *
 * We may assume that the database has already created a table named 'flight'.
 * It contains similar values as the Flight class:
 * flight_id, which is of type int,
 * departure_city, which is of type varchar(255),
 * arrival_city, which is of type varchar(255).
 */
public class FlightDAO {



    /**
     * TODO: Retrieve all flights from the flight table.
     *
     * You only need to change the sql String and set preparedStatement parameters.
     *
     * @return all flights.
     */
    public List<Flight> getAllFlights(){
        Connection connection = ConnectionUtil.getConnection();
        List<Flight> flights = new ArrayList<>();
        try {
            //Write SQL logic here
            String sql = "SELECT * FROM Flight";

            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            ResultSet rs = preparedStatement.executeQuery();
            while(rs.next()){
                Flight flight = new Flight(rs.getInt("flight_id"), rs.getString("departure_city"),
                        rs.getString("arrival_city"));
                flights.add(flight);
            }
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
        return flights;
    }

    /**
     * TODO: Retrieve a specific flight using its flight ID.
     *
     * You only need to change the sql String and set preparedStatement parameters.
     *
     * Remember that the format of a select where statement written as a Java String looks something like this:
     * String sql = "select * from TableName where ColumnName = ?";
     * The question marks will be filled in by the preparedStatement setString, setInt, etc methods. they follow
     * this format, where the first argument identifies the question mark to be filled (left to right, starting
     * from one) and the second argument identifies the value to be used:
     * preparedStatement.setInt(1,int1);
     *
     * @param id a flight ID.
     */
    public Flight getFlightById(int id){
        Connection connection = ConnectionUtil.getConnection();
        try {
            //Write SQL logic here
            String sql = "SELECT * FROM Flight where flight_id= ?;";
            
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1,id);
            //write preparedStatement's setString and setInt methods here.

            ResultSet rs = preparedStatement.executeQuery();
            while(rs.next()){
                Flight flight = new Flight(rs.getInt("flight_id"), rs.getString("departure_city"),
                        rs.getString("arrival_city"));
                return flight;
            }
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
        return null;
    }

    /**
     * TODO: Add a flight record into the database which matches the values contained in the flight object.
     * You can use the getters already written in the Flight class to retrieve its values (getDeparture_city(),
     * getArrival_city()). The flight_id will be automatically generated by the SQL database, and JDBC will be able
     * to retrieve the generated ID automatically. That means that you when you insert the flight, you only need
     * to define the departure_city and arrival_city values (two columns total!)
     *
     * You only need to change the sql String and set preparedStatement parameters.
     *
     * Remember that the format of a insert PreparedStatement written as a string works something like this:
     * String sql = "insert into TableName (ColumnName1, ColumnName2) values (?, ?);";
     * The question marks will be filled in by the preparedStatement setString, setInt, etc methods. they follow
     * this format, where the first argument identifies the question mark to be filled (left to right, starting
     * from one) and the second argument identifies the value to be used:
     * preparedStatement.setString(1,string1);
     * preparedStatement.setString(2,string2);
     *
     * @param flight an object modelling a Flight. the flight object does not contain a flight ID.
     */
    public Flight insertFlight(Flight flight){
        Connection connection = ConnectionUtil.getConnection();
        try {
            //Write SQL logic here. When inserting, you only need to define the departure_city and arrival_city
            //values (two columns total!)
            String sql = "INSERT INTO Flight (departure_city,arrival_city) VALUES(? , ?);" ;
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            //write preparedStatement's setString and setInt methods here.
            preparedStatement.setString(1,flight.getDeparture_city());
            preparedStatement.setString(2,flight.getArrival_city());

            preparedStatement.executeUpdate();
            ResultSet pkeyResultSet = preparedStatement.getGeneratedKeys();
            if(pkeyResultSet.next()){
                int generated_flight_id = (int) pkeyResultSet.getLong(1);
                return new Flight(generated_flight_id, flight.getDeparture_city(), flight.getArrival_city());
            }
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
        return null;
    }

    /**
     * TODO: Update the flight identified by the flight id to the values contained in the flight object.
     *
     * You only need to change the sql String and set preparedStatement parameters.
     *
     * Remember that the format of an update PreparedStatement written as a Java String looks something like this:
     * String sql = "update TableName set ColumnName1=?, ColumnName2=? where ColumnName3 = ?;";
     * The question marks will be filled in by the preparedStatement setString, setInt, etc methods. they follow
     * this format, where the first argument identifies the question mark to be filled (left to right, starting
     * from one) and the second argument identifies the value to be used:
     * preparedStatement.setString(1,string1);
     * preparedStatement.setString(2,string2);
     * preparedStatement.setInt(3,int1);
     *
     * @param id a flight ID.
     * @param flight a flight object. the flight object does not contain a flight ID.
     */
    public void updateFlight(int id, Flight flight){
        Connection connection = ConnectionUtil.getConnection();
        try {
            //Write SQL logic here
            String sql = "Update Flight SET departure_city = ? , arrival_city = ? WHERE flight_id = ?";
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            //write PreparedStatement setString and setInt methods here.
            preparedStatement.setString(1,flight.getDeparture_city());
            preparedStatement.setString(2,flight.getArrival_city());
            preparedStatement.setInt(3,id);


            preparedStatement.executeUpdate();
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
    }

    /**
     * TODO: Retrieve all flights following a particular flight path.
     *
     * you only need to change the sql string and set preparedStatement parameters.
     *
     * Remember that the format of a select where statement written as a Java String looks something like this:
     * "select * from TableName where ColumnName1 = ? and ColumnName2 = ?;";
     * The question marks will be filled in by the preparedStatement setString, setInt, etc methods. they follow
     * this format, where the first argument identifies the question mark to be filled (left to right, starting
     * from one) and the second argument identifies the value to be used:
     * preparedStatement.setString(1,"column 1 value");
     * preparedStatement.setString(2,"column 2 value");
     *
     * @param departure_city the departing city.
     * @param arrival_city the arriving city.
     * @return all flights from departure_city to arrival_city.
     */
    public List<Flight> getAllFlightsFromCityToCity(String departure_city, String arrival_city){
        Connection connection = ConnectionUtil.getConnection();
        List<Flight> flights = new ArrayList<>();
        try {
            //Write SQL logic here
            // String sql = "SELECT '"+departure_city+"','"+arrival_city+"' FROM Flight ";
            String sql = "SELECT * FROM Flight Where departure_city = ? and arrival_city = ?";

            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            //write Prepared


            package Application.Service;

            import Application.Model.Flight;
            import Application.DAO.FlightDAO;
            
            import java.util.List;
            
            /**
             * The purpose of a Service class is to contain "business logic" that sits between the web layer (controller) and
             * persistence layer (DAO). That means that the Service class performs tasks that aren't done through the web or
             * SQL: programming tasks like checking that the input is valid, conducting additional security checks, or saving the
             * actions undertaken by the API to a logging file.
             *
             * It's perfectly normal to have Service methods that only contain a single line that calls a DAO method. An
             * application that follows best practices will often have unnecessary code, but this makes the code more
             * readable and maintainable in the long run!
             */
            public class FlightService {
                FlightDAO flightDAO;
            
                /**
                 * No-args constructor for a flightService instantiates a plain flightDAO.
                 * There is no need to modify this constructor.
                 */
                public FlightService(){
                    flightDAO = new FlightDAO();
                }
            
                /**
                 * Constructor for a flightService when a flightDAO is provided.
                 * This is used for when a mock flightDAO that exhibits mock behavior is used in the test cases.
                 * This would allow the testing of FlightService independently of FlightDAO.
                 * There is no need to modify this constructor.
                 * @param flightDAO
                 */
                public FlightService(FlightDAO flightDAO){
                    this.flightDAO = flightDAO;
                }
            
                /**
                 * TODO: Use the FlightDAO to add a new flight to the database.
                 *
                 * This method should also return the added flight. A distinction should be made between *transient* and
                 * *persisted* objects - the *transient* flight Object given as the parameter will not contain the flight's id,
                 * because it is not yet a database record. When this method is used, it should return the full persisted flight,
                 * which will contain the flight's id. This way, any part of the application that uses this method has
                 * all information about the new flight, because knowing the new flight's ID is necessary. This means that the
                 * method should return the Flight returned by the flightDAO's insertFlight method, and not the flight provided by
                 * the parameter 'flight'.
                 *
                 * @param flight an object representing a new Flight.
                 * @return the newly added flight if the add operation was successful, including the flight_id. We do this to
                 *         inform our provide the front-end client with information about the added Flight.
                 */
                public Flight addFlight(Flight flight){
                    return flightDAO.insertFlight(flight);
                }
            
                /**
                 * TODO: Use the FlightDAO to update an existing flight from the database.
                 * You should first check that the flight ID already exists. To do this, you could use an if statement that checks
                 * if flightDAO.getFlightById returns null for the flight's ID, as this would indicate that the flight id does not
                 * exist.
                 *
                 * @param flight_id the ID of the flight to be modified.
                 * @param flight an object containing all data that should replace the values contained by the existing flight_id.
                 *         the flight object does not contain a flight ID.
                 * @return the newly updated flight if the update operation was successful. Return null if the update operation was
                 *         unsuccessful. We do this to inform our application about successful/unsuccessful operations. (eg, the
                 *         user should have some insight if they attempted to edit a nonexistent flight.)
                 */
                public Flight updateFlight(int flight_id, Flight flight){
                    if(flightDAO.getFlightById(flight_id)!=null){
                        flightDAO.updateFlight(flight_id, flight);
                        return flightDAO.getFlightById(flight_id);
                    }
                    return null;
                }
            
                /**
                 * TODO: Use the FlightDAO to retrieve a List containing all flights.
                 * You could use the flightDAO.getAllFlights method.
                 *
                 * @return all flights in the database.
                 */
                public List<Flight> getAllFlights() {
            
                    return flightDAO.getAllFlights();
                }
            
                /**
                 * TODO: Use the FlightDAO to retrieve a List containing all flights departing from a certain city and arriving at
                 * some other city. You could use the flightDAO.getAllFlightsFromCityToCity method.
                 *
                 * @param departure_city the departing city of the flight.
                 * @param arrival_city the arriving city of the flight.
                 * @return all flights departing from departure_city and arriving at arrival_city.
                 */
                public List<Flight> getAllFlightsFromCityToCity(String departure_city, String arrival_city) {
                    return flightDAO.getAllFlightsFromCityToCity(departure_city, arrival_city);
                }
            }




            package Application.Controller;

            import Application.Model.Flight;
            import Application.Service.FlightService;
            import com.fasterxml.jackson.core.JsonProcessingException;
            import com.fasterxml.jackson.databind.ObjectMapper;
            import io.javalin.Javalin;
            import io.javalin.http.Context;
            
            /**
             * There is no need to modify anything in this class. This class will create a Javalin API with four endpoints when the
             * startAPI method is called.
             *
             *  You can interact with the Javalin controller by
             *
             *  a) for GET requests, using the CURL command in your terminal (eg curl localhost:8080/flights). you can use post,
             *     but it's trickier to format with CURL: https://linuxize.com/post/curl-post-request/
             *  b) If you are working on your local machine and not in a browser-based IDE, navigating to an endpoint in your web
             *     browser (eg localhost:8080/flights) will perform a GET request.
             *  c) If you are working on your local machine and not in a browser-based IDE, using the desktop version of Postman
             *     for any type of request. Be sure to set the request type to the intended one (GET/POST/PUT/DELETE), and to
             *     properly format the body (setting the body content type to raw JSON).
             *
             *  The four included endpoints:
             *
             *  GET localhost:8080/flights : retrieve all flights
             *
             *  GET localhost:8080/flights/departing/{departure_city}/arriving/{arrival_city} : retrieve all flights departing
             *      from some city and arriving at some other city. For instance, writing Tampa as the departure city and Dallas
             *      as the arrival city will retrieve flights from Tampa to Dallas. This URL would be written as
             *      localhost/8080/flights/departing/tampa/arriving/dallas.
             *
             *  POST localhost:8080/flights : post a new flight. a new flight should be contained in the body of the request as a
             *      JSON representation, but without a flight_id (this should be generated automatically by the backend). example:
             *          {
             *              "departure_city":"Reston",
             *              "arrival_city":"Tampa"
             *          }
             *
             *  PUT localhost:8080/flights/{flight_id} : Replace the data identified by flight_id with a new representation which
             *      is in the request body. For instance, sending a request to
             *      localhost:8080/flights/1234 with the body
             *          {
             *              "departure_city":"Reston",
             *              "arrival_city":"Morgantown"
             *          }
             *      Will replace the values for departure_city and arrival_city for the resource identified by
             *      flight_id 1234.
             *
             */
            public class FlightController {
                FlightService flightService;
                public FlightController(){
                    flightService = new FlightService();
                }
                /**
                 * Method defines the structure of the Javalin Flights API. Javalin methods will use handler methods
                 * to manipulate the Context object, which is a special object provided by Javalin which contains information about
                 * HTTP requests and can generate responses. There is no need to change anything in this method. 
                 */
                public Javalin startAPI(){
                    Javalin app = Javalin.create();
                    app.post("/flights", this::postFlightHandler);
                    app.put("/flights/{flight_id}", this::updateFlightHandler);
                    app.get("/flights", this::getAllFlightsHandler);
                    app.get("/flights/departing/{departure_city}/arriving/{arrival_city}",
                            this::getAllFlightsDepartingFromCityArrivingToCityHandler);
                    return app;
                }
                /**
                 * Handler to post a new flight.
                 * The Jackson ObjectMapper will automatically convert the JSON of the POST request into a Flight object.
                 * If flightService returns a null flight (meaning posting a flight was unsuccessful, the API will return a 400
                 * message (client error). There is no need to change anything in this method.
                 * @param ctx the context object handles information HTTP requests and generates responses within Javalin. It will
                 *            be available to this method automatically thanks to the app.post method.
                 * @throws JsonProcessingException will be thrown if there is an issue converting JSON into an object.
                 */
                private void postFlightHandler(Context ctx) throws JsonProcessingException {
                    ObjectMapper mapper = new ObjectMapper();
                    Flight flight = mapper.readValue(ctx.body(), Flight.class);
                    Flight addedFlight = flightService.addFlight(flight);
                    if(addedFlight==null){
                        ctx.status(400);
                    }else{
                        ctx.json(mapper.writeValueAsString(addedFlight));
                    }
                }
            
                /**
                 * Handler to update a flight.
                 * The Jackson ObjectMapper will automatically convert the JSON of the POST request into a Flight object.
                 * to conform to RESTful standards, the flight that is being updated is identified from the path parameter,
                 * but the information required to update a flight is retrieved from the request body.
                 * If flightService returns a null flight (meaning updating a flight was unsuccessful), the API will return a 400
                 * status (client error). There is no need to change anything in this method.
                 *
                 * @param ctx the context object handles information HTTP requests and generates responses within Javalin. It will
                 *            be available to this method automatically thanks to the app.put method.
                 * @throws JsonProcessingException will be thrown if there is an issue converting JSON into an object.
                 */
                private void updateFlightHandler(Context ctx) throws JsonProcessingException {
                    ObjectMapper mapper = new ObjectMapper();
                    Flight flight = mapper.readValue(ctx.body(), Flight.class);
                    int flight_id = Integer.parseInt(ctx.pathParam("flight_id"));
                    Flight updatedFlight = flightService.updateFlight(flight_id, flight);
                    System.out.println(updatedFlight);
                    if(updatedFlight == null){
                        ctx.status(400);
                    }else{
                        ctx.json(mapper.writeValueAsString(updatedFlight));
                    }
            
                }
            
                /**
                 * Handler to retrieve all flights. There is no need to change anything in this method.
                 * @param ctx the context object handles information HTTP requests and generates responses within Javalin. It will
                 *            be available to this method automatically thanks to the app.put method.
                 */
                private void getAllFlightsHandler(Context ctx){
                    ctx.json(flightService.getAllFlights());
                }
                /**
                 * Handler to retrieve all flights departing from a particular city and arriving at another city.
                 * both cities are retrieved from the path. There is no need to change anything in this method.
                 * @param ctx the context object handles information HTTP requests and generates responses within Javalin. It will
                 *            be available to this method automatically thanks to the app.put method.
                 */
                private void getAllFlightsDepartingFromCityArrivingToCityHandler(Context ctx) {
                    ctx.json(flightService.getAllFlightsFromCityToCity(ctx.pathParam("departure_city"),
                            ctx.pathParam("arrival_city")));
                }
            }